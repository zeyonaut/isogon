#fragment 0

% This file contains an adaptation of Hurken's paradox, as described in:
% https://www.cs.cmu.edu/%7Ekw/scans/hurkens95tlca.pdf
% http://rutgerkuyper.com/pubs/bachelor.pdf
% Some non-standard phrases are introduced to make the paradox easier to understand.

% This causes elaboration to fail to terminate.

% The reason for nontermination is the validity of Type : Type.
def Type
	= * c0;

% We define negation with #0, but it doesn't actually matter what codomain we choose!
def not
	: Type -> Type
	= |T| T -> #0;

% We also define notions of powersets (containing subsets) and double powersets (containing subpowersets).
def P
	: Type -> Type
	= |T| T -> Type;

def PP
	: Type -> Type
	= |T| P (P T);

% Consider a powerful universe (U, s, t) of 'ordinals' (by analogy to the Burali-Forti paradox).
% An ordinal in U, for any type T, assigns to each 'reflection' of T a subpowerset of T.
def U
	= |T : Type| -> (PP T -> T) -> PP T;

% We can conceptualize t as a reflection of U:
% (This is probably the most confusing part of the paradox.)
def t
	: PP U -> U
	% If V is a U-subpowerset, T is a type, r is a T-reflection, and X is a T-subset,
	% return the proposition V assigns to the U-subset of ordinals x such that
	% the T-reflection of [the T-subpowerset that x assigns to r] is an element of X.
	= |V| |T| |r| |X| V (|x| X (r (x T r)));
	
% We can conceptualize s as an 'unreflection' of U:
def s
	: U -> PP U
	% If x is an ordinal, return the U-subpowerset that x assigns to t.
	= |x| x U t;

% For convenience, we define the composition of t after s:
def ts
	: U -> U
	= |x| t (s x);

% We also define a means of pulling back a subset X of U by an endofunction f to get a subset f* X:
def pullback
	: (U -> U) -> P U -> P U
	= |f| |X| |x| X (f x);

% If x and y are ordinals and X is a subset of U, we say that x 'locally dominates' y at x
% (for lack of a better phrase) iff:
% if sx contains X, then X contains y.
def locally_dominates_at
	: U -> U -> PP U
	= |x| |y| |X| s x X -> X y;

% If X is a subset of U, we say that X is 'inductive' iff:
% for all ordinals x of U, x locally dominates x at X.
def is_inductive
	: PP U
	= |X| |x : U| -> locally_dominates_at x x X;

% If x and y are ordinals of U, we say that x dominates y (i.e., x > y) iff:
% for all subsets X of U, x locally dominates y at X.
def dominates
	: U -> P U
	= |x| |y| |X : P U| -> locally_dominates_at x y X;

% We define the paradoxical subset O by the following:
def O
	: U
	= t is_inductive;

% If x is an ordinal of U, we say that x is 'decent' (a.k.a. 'well-founded') iff:
% for all subsets X of U, if X is inductive, then X contains x.
def is_decent
	: P U
	= |x| |X : P U| -> is_inductive X -> X x;

% We show that O is decent:
def proof_O_is_decent
	: is_decent O
	= |X| |proof_X_is_inductive| ( % Suppose X is an inductive subset of U. We wish to show X contains O.
		% First, we show that sO contains X:
		def proof_sO_contains_X
			: s O X
			= |x| proof_X_is_inductive (ts x);

		% Since X is inductive, then X contains O, as required:
		def proof_X_contains_O
			: X O
			= proof_X_is_inductive O proof_sO_contains_X;

		proof_X_contains_O
	);

% If x is an ordinal of U, we say that x is 'dubious'
% (for lack of a better phrase) iff:
% x dominates tsx.
def is_dubious
	: P U
	= |x| dominates x (ts x);

% This is definitionally the same as being 'locally dubious' at every subset:
def is_locally_dubious
	: U -> PP U
	= |x| |X| locally_dominates_at x (ts x) X;

% We also define a subset ND of 'nondubious' ordinals:
def is_nondubious
	: P U
	= |x| not (is_dubious x);

def ND = is_nondubious;

% First, we show that O is dubious (i.e., O > ts O):
def proof_O_is_dubious
	: is_dubious O = |X| proof_O_is_decent (pullback ts X);

% First, we show that the subset of nondubious ordinals is inductive:
def proof_ND_is_inductive
	: is_inductive ND
	= |x| |proof_sx_contains_ND| (
		% Suppose x is an ordinal of U such that sx contains ND. We wish to show that ND contains x.
		% That is, we are required to show that x is nondubious:
		def proof_x_is_nondubious : is_nondubious x
			= |proof_x_is_dubious| ( % Suppose x is dubious. We wish to show a contradiction.
				% First, we show that tsx is nondubious (i.e., tsx !> tstsx):
				def proof_tsx_is_nondubious
					: is_nondubious (ts x)
					= proof_x_is_dubious ND proof_sx_contains_ND;

				% Next, we show that tsx is dubious (i.e., tsx > tstsx):
				def proof_tsx_is_dubious
					: is_dubious (ts x)
					= |X| ( % Suppose X is a subset of U. We wish to show that tsx is locally dubious at X.
						% We show that x is locally dubious at ts* X:
						def x_is_locally_dubious_at_pb_ts_X
							: is_locally_dubious x (pullback ts X)
							= proof_x_is_dubious (pullback ts X);

						% This is definitionally the same as saying that tsx is locally dubious at X, as required:
						def tsx_is_locally_dubious_at_X
							: is_locally_dubious (ts x) X
							= x_is_locally_dubious_at_pb_ts_X;
						
						tsx_is_locally_dubious_at_X
					);

				% This yields a contradiction.
				proof_tsx_is_nondubious proof_tsx_is_dubious
			);

		proof_x_is_nondubious
	);

% This lets us show that O is nondubious (i.e., O !> ts O):
def proof_O_is_nondubious
	: is_nondubious O
	= proof_O_is_decent ND proof_ND_is_inductive;

% This yields a contradiction, which fails to terminate.
<proof_O_is_nondubious proof_O_is_dubious :: |_| '#0 {}>
